# ClosedBlind

UNISWAP v1:
In Uniswap V1, liquidity pools were strictly limited to ETH paired with a single ERC-20 token, meaning no direct ERC-20-to-ERC-20 pools existed
Initial Exchange Factory: 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95
Contains only initialize factory (that point to 0x2157A7894439191e520825fe9399aB8655E0f708) and the Method CreateExchange
Exchange code Template: 0x2157A7894439191e520825fe9399aB8655E0f708

# Undertand ETH Transaction
{'type': 0, # Transaction type (pre-EIP-1559 etc etc)
 'chainId': 1, # The identifier of the Ethereum network (e.g. 1 = mainnet).
 'nonce': 3The identifier of the Ethereum network (e.g. 1 = mainnet).,
 'gasPrice': 12000000000, # The sequential number of transactions sent from this sender‚Äôs address.
 'gas': 1000000, # The maximum gas units allocated for executing the transaction.
 'to': '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95', # The recipient's address (20-byte hex string).
 'value': 0, # Amount of Ether (in Wei) being transferred.
 'input': HexBytes('0x538a3f0e0000000000000000000000002157a7894439191e520825fe9399ab8655e0f708'), # The transaction data payload For contract calls: includes the function signature and parameters.
 'r': HexBytes('0x24753ee86e7ee6aa395e8edd5bfff1fa16494ad84a8648456064a7a658ecb2c4'), # Components of the transaction's ECDSA signature, r and s: the signature values.
 's': HexBytes('0x641511ccacad0ac1c8bbd0026a176a7b9b64a32a2a259ea07f94b646fe606749'),
 'v': 38, # the recovery identifier (used to reconstruct the sender‚Äôs public key, and includes chain ID per EIP-155).
 'hash': HexBytes('0x4ef102aebb98c3185396578bcf6f71d0c3c13773caef02514639b9141948245b'), # The unique identifier of the transaction, generated by hashing the signed transaction.
 'blockHash': HexBytes('0xca9c35cc900041acbc2dce3c7121c2e9050c64bdc6752a043de437150387bcd1'), # The hash of the block containing this transaction. null if the transaction is still pending.
 'blockNumber': 6627944, # The block number in which this transaction was included. null if pending.
 'transactionIndex': 54, # The position (index) of this transaction within the block. null if not yet included in a block.
 'from': '0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2'} # The address that initiated the transaction (sender).

# Understand ETH Rceipt
{
  "transactionHash": "0x1b53439a36b357c712a4abe860607c6e4d88a002dd26f97244a8ef3208b2f8b6",
  "__comment_transactionHash": "Unique identifier of this transaction",
  
  "blockHash": "0x96ba61eb50602507ce0bcfc98ec4e9b363d624a6efb1140916be38906fcdad66",
  "__comment_blockHash": "Hash of the block that included this transaction",
  
  "blockNumber": 6845141,
  "__comment_blockNumber": "Number of the block containing the transaction; used for ordering and filtering",
  
  "transactionIndex": 75,
  "__comment_transactionIndex": "Position of this transaction within the block",
  
  "from": "0x3DE8C28084fd46F3c47D2bA16784a95E647f25B6",
  "__comment_from": "Address of the sender who initiated the transaction",
  
  "to": "0x255e60c9d597dCAA66006A904eD36424F7B26286",
  "__comment_to": "Address of the recipient; can be a contract or external account",
  
  "contractAddress": null,
  "__comment_contractAddress": "If the transaction creates a contract, this will contain its address; null otherwise",
  
  "status": 1,
  "__comment_status": "1 indicates success, 0 indicates a revert/failure",
  
  "type": 0,
  "__comment_type": "Transaction type: 0 = legacy, 2 = EIP-1559",
  
  "gasUsed": 109035,
  "__comment_gasUsed": "Amount of gas actually consumed by this transaction",
  
  "cumulativeGasUsed": 3258458,
  "__comment_cumulativeGasUsed": "Total gas used in the block up to and including this transaction",
  
  "effectiveGasPrice": 5000000000,
  "__comment_effectiveGasPrice": "Gas price paid per unit of gas (in wei); used to calculate transaction fee",
  
  "logsBloom": "0x00000000010000800000000000000000000000000000000000000000000000000000000020000000000000000000100000400000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000002000400000000000000080000000000000000000100001000000800000000000000000000000000000000000000044000000000000000000000008000000000000000000000000108400000000000400000100000000000000000000020008000000000000000000000000000000000000000000000028600000000000000000000000000000000000000000000000000000000004",
  "__comment_logsBloom": "Bloom filter summarizing all events in the transaction; used for efficient on-chain event queries",
  
  "logs": [
    {
      "address": "0xB8c77482e45F1F44dE1745F52C74426C631bDD52",
      "__comment_address": "Contract address that emitted this event",
      
      "topics": [
        "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
        "0x0000000000000000000000003de8c28084fd46f3c47d2ba16784a95e647f25b6",
        "0x000000000000000000000000255e60c9d597dcaa66006a904ed36424f7b26286"
      ],
      "__comment_topics": "Indexed event fields; these can be used for filtering and decoding with the ABI",
      
      "data": "0x000000000000000000000000000000000000000000000000011854d0f9cee40000",
      "__comment_data": "Non-indexed event fields containing actual event data; decode using ABI",
      
      "blockNumber": 6845141,
      "__comment_blockNumber": "Block number containing this log",
      
      "transactionHash": "0x1b53439a36b357c712a4abe860607c6e4d88a002dd26f97244a8ef3208b2f8b6",
      "__comment_transactionHash": "Hash of the transaction that emitted this log",
      
      "transactionIndex": 75,
      "__comment_transactionIndex": "Position of the transaction in the block",
      
      "logIndex": 39,
      "__comment_logIndex": "Position of the log within the block",
      
      "removed": false,
      "__comment_removed": "Indicates if the log was removed due to chain reorg; false means it is still valid"
    },
    {
      "address": "0x255e60c9d597dCAA66006A904eD36424F7B26286",
      "topics": [
        "0x06239653922ac7bea6aa2b19dc486b9361821d37712eb796adfd38d81de278ca",
        "0x0000000000000000000000003de8c28084fd46f3c47d2ba16784a95e647f25b6",
        "0x0000000000000000000000000000000000000000000000000de0b6b3a7640000",
        "0x000000000000000000000000000000000000000000000000011854d0f9cee40000"
      ],
      "data": "0x",
      "blockNumber": 6845141,
      "transactionHash": "0x1b53439a36b357c712a4abe860607c6e4d88a002dd26f97244a8ef3208b2f8b6",
      "transactionIndex": 75,
      "logIndex": 40,
      "removed": false,
      "__comment": "Another event log; similar meaning as above. 'data' may be empty if all fields are indexed"
    },
    {
      "address": "0x255e60c9d597dCAA66006A904eD36424F7B26286",
      "topics": [
        "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
        "0x0000000000000000000000000000000000000000000000000000000000000000",
        "0x0000000000000000000000003de8c28084fd46f3c47d2ba16784a95e647f25b6"
      ],
      "data": "0x0000000000000000000000000000000000000000000000000de0b6b3a7640000",
      "blockNumber": 6845141,
      "transactionHash": "0x1b53439a36b357c712a4abe860607c6e4d88a002dd26f97244a8ef3208b2f8b6",
      "transactionIndex": 75,
      "logIndex": 41,
      "removed": false,
      "__comment": "Yet another event; all logs together allow reconstructing the function effects and state changes"
    }
  ]
}


# Convert HexBytes to read it
```
from web3 import Web3
import json

w3 = Web3(Web3.HTTPProvider(YOUR_NODE_URL))
tx = w3.eth.get_transaction(tx_hash)

with open('YourContractABI.json') as f:
    abi = json.load(f)

contract = w3.eth.contract(address=tx['to'], abi=abi)
function, params = contract.decode_function_input(tx['input'])

print('Called function:', function.fn_name)
print('With arguments:', params)
```


# Decode Name in Byte32
```
from web3 import Web3

# Example bytes32 value
hex_val = "0x556e697377617020563100000000000000000000000000000000000000000000"

# Convert hex to bytes
raw = Web3.to_bytes(hexstr=hex_val)

# Decode to string and strip trailing null bytes
decoded = raw.rstrip(b'\x00').decode('utf-8')

print(decoded)  # Outputs: Uniswap V1
```



üîé What you can and cannot get from a real, mined transaction
‚úÖ Things you can get:

Transaction receipt ‚Üí via w3.eth.get_transaction_receipt(tx_hash)
Contains:

status (success/revert)

gasUsed

logs (all emitted events)

contractAddress (if contract creation)

cumulativeGasUsed

Transaction itself ‚Üí via w3.eth.get_transaction(tx_hash)
Contains:

from, to, value

input (the encoded function call + arguments)

gas, gasPrice

Decoded input ‚Üí if you have the ABI, you can decode input back to function name + arguments:

fn, args = contract.decode_function_input(tx['input'])

‚ùå Things you cannot directly get (from receipts):

The return value of a contract function call (that‚Äôs not part of logs).
Once a transaction is mined, return values are not stored on-chain ‚Äî only events/logs and state changes persist.
‚Üí Etherscan doesn‚Äôt show return values either, for the same reason.

The execution trace (line-by-line execution inside the EVM).
Ethereum JSON-RPC does not expose this in receipts.
But: you can get it via trace APIs if your node supports them (like Reth with trace_transaction).

üõ†Ô∏è How to get maximum information with Web3.py
1. Get transaction + receipt
tx = w3.eth.get_transaction(tx_hash)
receipt = w3.eth.get_transaction_receipt(tx_hash)

print("From:", tx['from'])
print("To:", tx['to'])
print("Gas limit:", tx['gas'])
print("Gas used:", receipt['gasUsed'])
print("Status:", receipt['status'])
print("Logs:", receipt['logs'])

2. If you want return values

You can‚Äôt read them from history ‚Äî but you can re-execute the call locally as a call, which simulates the function without changing state:

# Simulate the transaction as a call at the same block
result = w3.eth.call({
    "to": tx['to'],
    "data": tx['input']
}, block_identifier=receipt['blockNumber'])

print("Return value (raw):", result.hex())


If you have the ABI, decode it:

fn, _ = contract.decode_function_input(tx['input'])
decoded = fn.decode_output(result)
print("Decoded return:", decoded)


‚ö†Ô∏è Caveat: this works only if

the function is view/pure, or

the historical state at that block still allows re-execution deterministically.
For state-changing functions, the return value in the original transaction is discarded ‚Äî you won‚Äôt recover it.

3. If you want execution trace

Since you‚Äôre running Reth with trace API, you can request full execution traces:

trace = w3.provider.make_request("trace_transaction", [tx_hash])
print(trace['result'])


This gives you:

Internal calls (CALL, DELEGATECALL, STATICCALL)

Gas used at each step

Return data for each sub-call

That‚Äôs the only way to see the ‚Äúline-by-line‚Äù execution after the fact.

‚úÖ Summary

Gas used, logs, status ‚Üí always available via receipt.

Function name + args ‚Üí decode input with ABI.

Return values:

Not stored on-chain if state-changing

Can simulate with eth_call at historical block (works for view/pure).

Detailed execution (internal calls, return values, gas breakdown) ‚Üí use trace_transaction from your Reth node.